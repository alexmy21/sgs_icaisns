"""
MIT License

Copyright (c) 2022: Julia Computing Inc. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Source code is on github
https://github.com/JuliaComputing/SQLiteGraph.jl.git

I borrowed a lot from this project, but also made a lot of changes, 
so, for all errors do not blame the original author but me.
"""


include("sets32.jl")
include("utils.jl")

module HllGraph

    using ..HllSets
    using ..Util

    # using TidierDB
    using Redis
    using JSON3: JSON3
    using EasyConfig
    using DataFrames: DataFrame
    using DataFrames: DataFrameRow

    # export Graph, Node, Edge

    abstract type AbstractGraphType end

    #-----------------------------------------------------------------------------# Node
    """
    Fields
        - sha1::String: A string field intended to uniquely identify the node, possibly using a SHA-1 hash.
        - labels::Vector{String}: A vector of strings representing labels or categories associated with the node.
        - dataset::Vector{UInt64}: A vector of unsigned 64-bit integers representing some dataset associated with the node.
        - search::String: A string, derived from the dataset field, 
            intended to be used for search or indexing purposes. 
            This field is generated by converting the dataset from Vector{UInt64} to String 
            using Uttil.toblob(. . .) function.
    """
    mutable struct Node <: AbstractGraphType
        sha1::String
        labels::String
        dataset::Vector{UInt64}
        searchable::String

        # # Inner constructor
        function Node(sha1::String, labels::String, dataset::Vector{UInt64}) 
            # float32_data = Float32.(dataset)
            searchable = Util.to_blob(dataset)           
            new(sha1, labels, dataset, searchable)
        end
        # Constructor that takes a dictionary
        function Node(dict::Dict{AbstractString, Any})
            sha1 = dict["sha1"]
            labels = dict["labels"]
            if typeof(dict["dataset"]) == String
                dataset = JSON3.read(dict["dataset"], Vector{UInt64})
            elseif typeof(dict["dataset"]) == Vector{UInt64}
                dataset = dict["dataset"]
            elseif typeof(dict["dataset"]) == Vector{UInt8}
                dataset = JSON3.read(dict["dataset"], Vector{UInt64})
            else
                throw(ArgumentError("Argument dataset must be of type String, Vector{UInt64} or Vector{UInt8}"))
            end
            searchable = Util.to_blob(dataset) 
            new(sha1, labels, dataset, searchable) 
        end

        # Constructor that takes a dictionary from Redis hash
        function Node(dict::Dict{AbstractString, AbstractString})
            sha1 = dict["sha1"]
            labels = dict["labels"]
            dataset = JSON3.read(dict["dataset"], Vector{UInt64})
            # println("dataset: ", length(dataset))
            searchable = Util.to_blob(dataset) 
            new(sha1, labels, dataset, searchable) 
        end
    end

    Node(row::DataFrameRow) = 
        Node(row.sha1, row.labels, JSON3.read(row.dataset, Vector{UInt64}))
    # Node(dict::Dict{String,Any}) = 
    #     Node(dict["sha1"], JSON3.read(dict["labels"]), Util.to_uint64_vector(dict["dataset"]))
    
    function Base.show(io::IO, o::Node)
        print(io, "Node($(o.sha1)")
        print(io, "; ") 
        print(io, o.labels)
        print(io, "; ")
        print(io, card(o))
        print(io, ')')
    end

    args(n::Node) = (n.sha1, n.labels, JSON3.write(n.dataset))
    dict(n::Node) = Dict{Symbol, Any}(:sha1 => n.sha1, 
                    :labels => n.labels, 
                    :dataset => JSON3.write(n.dataset),
                    :searchable => n.searchable)
    card(n::Node, P::Int=10) = HllSets.count(HllSets.restore(HllSet{P}(), UInt64.(n.dataset)))

    #-----------------------------------------------------------------------------# Edge
    struct Edge <: AbstractGraphType
        source::String
        target::String
        r_type::String
        props::Config
    end

    Edge(src::String, tgt::String, r_type::String; props...) = Edge(src, tgt, r_type, Config(props))
    Edge(row::DataFrameRow) = Edge(row.source, row.target, row.r_type, JSON3.read(row.props, Config))
    Edge(dict::Dict{Symbol,Any}) = Edge(dict["source"], dict["target"], dict["r_type"], JSON3.read(dict["props"], Config))
    # Dict from Redis hash
    Edge(dict::Dict{AbstractString,AbstractString}) = Edge(dict["source"], dict["target"], dict["r_type"], JSON3.read(dict["props"], Config))

    function Base.show(io::IO, o::Edge)
        print(io, "Edge($(o.source), $(o.target), ", repr(o.r_type))
        !isempty(o.props) && print(io, "; "); print_props(io, o.props)
        print(io, ')')
    end

    args(e::Edge) = (e.source, e.target, e.r_type, JSON3.write(e.props))
    dict(e::Edge) = Dict(:source => e.source, :target => e.target, :r_type => e.r_type, :props => JSON3.write(e.props))

    #-----------------------------------------------------------------------------# Graph
    struct Graph
        nodes::Vector{Node}
        edges::Vector{Edge}
    end

    #-----------------------------------------------------------------------------# Base methods
    Base.:(==)(a::Node, b::Node) = all(getfield(a,f) == getfield(b,f) for f in fieldnames(Node))
    Base.:(==)(a::Edge, b::Edge) = all(getfield(a,f) == getfield(b,f) for f in fieldnames(Edge))

    Base.pairs(o::T) where {T<: Union{Node, Edge}} = (f => getfield(o,f) for f in fieldnames(T))

    Base.NamedTuple(o::Union{Node,Edge}) = NamedTuple(pairs(o))     
    
    # Graph operations
    #-----------------------------------------------------------------------------#
    # function create_node(hll::HllSets.HllSet{T}, labels::String) where T
    #     sha1 = HllSets.id(hll)
    #     dataset = HllSets.dump(hll) # Convert the HLL set to a vector of UInt64
    #     return Node(sha1, labels, dataset)
    # end

    # function create_node(data::String, labels::String)
    #     parsed_tokens = split(data, r"\W+")  # Split by non-word characters
    #     return create_node(parsed_tokens, labels)
    # end

    function create_node(data::Vector{String}, labels::String)
        hll = HllSets.HllSet{10}()
        for token in data
            HllSets.add!(hll, token)
        end
        sha1 = HllSets.id(hll)
        dataset = HllSets.dump(hll) # Convert the HLL set to a vector of UInt64
        return Node(sha1, labels, dataset)
        # return create_node(hll, labels)
    end

    function set_node(conn::RedisConnection, node::Node, status::String)        
        key_name, node_dict = set_node(conn, node, status, true)
        Redis.hmset(conn, key_name, node_dict)
    end

    function set_node(conn::RedisConnection, node::Node, status::String, pipe::Bool)        
        key_name = status * ":" * "n" * ":" * node.sha1
        node_hash = Redis.hgetall(conn, key_name)

        if node_hash != nothing && !isempty(node_hash) 
            lbl     = node_hash["labels"]
            lblset  = Set(split(lbl, ","))
            # update token.token in case we have new token with the same hash
            lblset = union(lblset, Set(split(node.labels, ","))) 
            cnt_lbl = join(lblset, ",")
            node.labels = cnt_lbl
        end

        if pipe
            return key_name, dict(node)
        else
            Redis.hmset(conn, key_name, node_dict)
        end
    end

    function set_edge(conn::RedisConnection, edge::Edge, status::String)
        edge_dict = dict(edge)  
        key_name = status * ":" * "e" * ":" * edge.source * ":" * edge.target
        Redis.hmset(conn, key_name, edge_dict)
    end

    # Implement get_node and get_edge functions
    #-----------------------------------------------------------------------------#
    function get_node(conn::RedisConnection, sha1::String, status::String)
        key_name = status * ":" * "n" * ":" * sha1
        node_dict = Redis.hgetall(conn, key_name)
        return Node(node_dict)
    end

    function get_edge(conn::RedisConnection, source::String, target::String, status::String)
        key_name = status * ":" * "e" * ":" * source * ":" * target
        edge_dict = Redis.hgetall(conn, key_name)
        dict_converted = Dict{String, Any}(String(k) => String(v) for (k, v) in edge_dict)

        return Edge(dict_converted)
    end

    # Implement get_nodes and get_edges functions to get multiple nodes and edges
    #-----------------------------------------------------------------------------#
    function get_nodes(conn::RedisConnection, status::String)
        nodes = []
        cursor = 0
        pattern = status * ":n:*"
        while true
            cursor, keys = Redis.scan(conn, cursor, "match", pattern)
            for key in keys
                node_dict = Redis.hgetall(conn, key)
                push!(nodes, Node(node_dict))
            end
            # Check the condition at the end of the loop body
            if cursor == 0
                break  # Exit the loop if the condition is met
            end
        end
        return nodes
    end

    function get_edges(conn::RedisConnection, status::String)
        edges = []
        cursor = 0
        pattern = status * ":e:*"
        while true
            cursor, keys = Redis.scan(conn, cursor, "match", pattern)
            for key in keys
                edge_dict = Redis.hgetall(conn, key)
                push!(edges, Edge(edge_dict))
            end
            # Check the condition at the end of the loop body
            if cursor == 0
                break  # Exit the loop if the condition is met
            end
        end
        return edges
    end

    # Set operations on Nodes
    #-----------------------------------------------------------------------------#
    function union_nodes(node_1::Node, node_2::Node, labels::String)
        union_hll = HllSets.union(to_hll_set(node_1), to_hll_set(node_2))
        union_sha1 = sha1_union([node_1.sha1, node_2.sha1])
        
        return Node(union_sha1, labels, HllSets.dump(union_hll))
    end

    function intersect_nodes(node_1::Node, node_2::Node, labels::String)
        intersect_hll = HllSets.intersection(to_hll_set(node_1), to_hll_set(node_2))
        intersect_sha1 = sha1_intersect([node_1.sha1, node_2.sha1])
        
        return Node(intersect_sha1, labels, HllSets.dump(intersect_hll))
    end

    function comp_nodes(node_1::Node, node_2::Node, labels::String)
        comp_hll = HllSets.complement(to_hll_set(node_1), to_hll_set(node_2))
        comp_sha1 = sha1_comp(node_1.sha1, node_2.sha1)
        
        return Node(comp_sha1, labels, HllSets.dump(comp_hll))
    end

    function xor_nodes(node_1::Node, node_2::Node, labels::String)
        xor_hll = HllSets.xor(to_hll_set(node_1), to_hll_set(node_2))
        xor_sha1 = sha1_xor(node_1.sha1, node_2.sha1)
        
        return Node(xor_sha1, labels, HllSets.dump(xor_hll))
    end

    # Compound functions that perform Set operations on Nodes and submit the results
    # to the Redis db. These function also create edges between the input nodes and the
    # result node.
    #-----------------------------------------------------------------------------#
    function union_nodes(conn::RedisConnection, node_1::Node, node_2::Node, labels::String, status::String)
        union_node = union_nodes(node_1, node_2, labels)

        edge_1 = Edge(node_1.sha1, union_node.sha1, "union")
        edge_2 = Edge(node_2.sha1, union_node.sha1, "union")

        set_node(conn, union_node, status)
        set_edge(conn, edge_1, status)
        set_edge(conn, edge_2, status)

        return union_node
    end

    function intersect_nodes(conn::RedisConnection, node_1::Node, node_2::Node, labels::String, status::String)
        intersect_node = intersect_nodes(node_1, node_2, labels)

        edge_1 = Edge(node_1.sha1, intersect_node.sha1, "intersect")
        edge_2 = Edge(node_2.sha1, intersect_node.sha1, "intersect")

        set_node(conn, intersect_node, status)
        set_edge(conn, edge_1, status)
        set_edge(conn, edge_2, status)

        return intersect_node
    end

    function comp_nodes(conn::RedisConnection, node_1::Node, node_2::Node, labels::String, status::String)
        comp_node = comp_nodes(node_1, node_2, labels)

        edge_1 = Edge(node_1.sha1, comp_node.sha1, "comp")
        edge_2 = Edge(node_2.sha1, comp_node.sha1, "comp")

        set_node(conn, comp_node, status)
        set_edge(conn, edge_1, status)
        set_edge(conn, edge_2, status)

        return comp_node
    end

    function xor_nodes(conn::RedisConnection, node_1::Node, node_2::Node, labels::String, status::String)
        xor_node = xor_nodes(node_1, node_2, labels)

        edge_1 = Edge(node_1.sha1, xor_node.sha1, "xor")
        edge_2 = Edge(node_2.sha1, xor_node.sha1, "xor")

        set_node(conn, xor_node, status)
        set_edge(conn, edge_1, status)
        set_edge(conn, edge_2, status)

        return xor_node
    end

    # Implement intersection_nodes function
    #-----------------------------------------------------------------------------#
    function to_hll_set(node::Node; P::Int=10)
        z = HllSet{P}()
        return HllSets.restore(z, UInt64.(node.dataset))
    end

    # Function to create arrays of SHA1 strings and HLLSets from a set of Nodes
    function get_sha1_hll(nodes::Set{Node}; P::Int=10)
        sha1_array = String[]
        hllSet_array = Vector{HllSet{P}}[]

        for node in nodes
            z = HllSet{P}()
            push!(sha1_array, node.sha1)
            push!(hllSet_array, to_hll_set(node))
        end

        return sha1_array, hllSet_array
    end

    # RediSearch indices
    #-------------------------------------------------------------------------------#
    function node_idx(conn::RedisConnection, idx_name::String, idx_prefix::String)
        try
            Redis.execute_command(conn, ["FT.CREATE", "$idx_name", "ON", "HASH", "PREFIX", 1, "$idx_prefix", 
                "SCHEMA", "sha1", "TEXT", "labels", "TAG", "searchable", 
                "VECTOR", 
                "HNSW", 
                "16", 
                "TYPE", 
                "FLOAT32", 
                "DIM", 
                "1024", 
                "DISTANCE_METRIC", 
                "L2",
                "INITIAL_CAP", 
                "1400000", 
                "M", 
                "40", 
                "EF_CONSTRUCTION", 
                "100", 
                "EF_RUNTIME", 
                "20", 
                "EPSILON", 
                "0.8"])
        catch e
            println(e)
        end
    end

    """
        source::String
        target::String
        r_type::String
        props::Config
    """   
    function edge_idx(conn::RedisConnection, idx_name::String, idx_prefix::String)
        try
            Redis.execute_command(conn, ["FT.CREATE", "$idx_name", "ON", "HASH", "PREFIX", 1, "$idx_prefix", 
                "SCHEMA", "source", "TEXT", "target", "TEXT", "r_type", "TEXT", "props", "TEXT"])
        catch e
            println(e)
        end
    end
end
